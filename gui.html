<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Connect 4 AI - Minimax Visualization</title>
    <style>
        :root{
            --bg-dark: #0b0f1a;
            --card: rgba(255,255,255,0.04);
            --glass: rgba(255,255,255,0.03);
            --pink: #ff6bcb;
            --yellow: #ffd166;
            --blue: #4da3ff;
            --green: #06d6a0;
            --muted: #9aa6b2;
            --white: #ffffff;
            --overlay-bg: rgba(3,6,15,0.75);
        }

        *{box-sizing:border-box;margin:0;padding:0}
        html,body{height:100%}
        body{
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            background: linear-gradient(160deg,#071028 0%,#0b0f1a 60%);
            color:var(--white);
            padding:22px;
            min-height:100vh;
        }

        .container{max-width:1400px;margin:0 auto}
        .header{text-align:center;margin-bottom:18px}
        .header h1{
            font-size:2.2rem;
            background:linear-gradient(90deg,var(--pink),var(--yellow));
            -webkit-background-clip:text;
            -webkit-text-fill-color:transparent;
            margin-bottom:6px;
        }
        .header p{color:var(--muted)}

        .main-grid{
            display:grid;
            grid-template-columns:360px 1fr;
            grid-template-rows:auto 460px;
            gap:18px;
            align-items:start;
        }

        .card{
            background: linear-gradient(180deg,var(--card),var(--glass));
            border-radius:14px;padding:18px;
            box-shadow:0 8px 30px rgba(2,6,23,0.6);
            border:1px solid rgba(255,255,255,0.03);
        }
        .card-header{
            background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            margin:-18px -18px 12px -18px;padding:12px 16px;border-radius:12px 12px 0 0;
            font-weight:700;color:var(--muted);font-size:.98rem;
        }

        .controls{display:flex;flex-direction:column;gap:12px}
        .settings-label{display:block;margin-bottom:8px;color:var(--muted);font-weight:700}
        .radio-group{display:flex;flex-direction:column;gap:8px}
        .radio-option{
            display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:10px;
            cursor:pointer;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
            border:1px solid rgba(255,255,255,0.03);transition:all .18s;font-weight:600;color:var(--white);
        }
        .radio-option.selected{
            box-shadow:0 6px 20px rgba(255,107,203,0.12);
            border:1px solid rgba(255,214,102,0.2);
            background:linear-gradient(90deg, rgba(255,107,203,0.08), rgba(77,163,255,0.04));
        }
        .slider-container{padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border:1px solid rgba(255,255,255,0.03);text-align:center}
        .depth-value{font-size:1.4rem;color:var(--yellow);font-weight:800;margin-bottom:8px}

        .controls-actions{display:flex;flex-direction:column;gap:10px;margin-top:6px}
        .btn{padding:12px 14px;border-radius:10px;font-weight:800;cursor:pointer;border:none;color:#071028;transition:all .14s}
        .btn-start{background:linear-gradient(90deg,var(--yellow),var(--pink));}
        .btn-reset{background:linear-gradient(90deg,var(--blue),#82c7ff);}
        .btn:disabled{opacity:.5;cursor:not-allowed}

        .status-card{background:transparent;padding:10px;border-radius:8px;border:1px dashed rgba(255,255,255,0.02)}
        .status-label{color:var(--muted);font-size:.82rem;margin-bottom:6px}
        .status-value{font-weight:800;color:var(--white);font-size:1.05rem}

        .board-card{display:flex;flex-direction:column;gap:12px}
        .board-container{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));padding:18px;border-radius:12px}
        .column-indicators{display:grid;grid-template-columns:repeat(7,1fr);gap:8px;margin-bottom:8px}
        .column-indicator{text-align:center;font-size:1.2rem;color:transparent;transition:color .18s}
        .column-indicator.active{color:var(--pink);filter:drop-shadow(0 6px 18px rgba(255,107,203,0.12))}
        .board-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:10px;justify-items:center;padding:10px;border-radius:12px}
        .cell{width:64px;height:64px;background:#07172a;border-radius:50%;border:2px solid rgba(255,255,255,0.03);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .18s}
        .cell:hover:not(.filled){transform:translateY(-4px);box-shadow:0 10px 30px rgba(0,0,0,0.45);border-color:rgba(255,255,255,0.06)}
        .cell.filled{cursor:default}
        .cell.human{background:radial-gradient(circle at 35% 25%, rgba(255,107,203,0.95),#ff3fb0 35%,#ff2e95 100%);border-color:rgba(255,107,203,0.7);box-shadow:0 0 22px rgba(255,107,203,0.12)}
        .cell.ai{background:radial-gradient(circle at 30% 35%, rgba(77,163,255,0.95),#4da3ff 35%,#2f93ff 100%);border-color:rgba(77,163,255,0.7);box-shadow:0 0 22px rgba(77,163,255,0.12)}
        .cell.last-move{border-width:4px;border-color:var(--yellow);animation:pulse 1s infinite}
        @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.04)}}
        .legend{display:flex;gap:20px;justify-content:center;margin-top:8px}
        .legend-item{display:flex;gap:10px;align-items:center;font-weight:700;color:var(--muted)}
        .legend-disc{width:20px;height:20px;border-radius:50%}
        .legend-disc.human{background:linear-gradient(90deg,var(--pink),#ff3fb0)}
        .legend-disc.ai{background:linear-gradient(90deg,var(--blue),#8fd1ff)}

        .tree-area{grid-column:1 / -1;min-height:380px;max-height:720px;overflow:hidden}
        .tree-canvas-container{
            background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
            border-radius:10px;padding:12px;height:100%;
            overflow-x:auto;overflow-y:auto;position:relative;
        }
        #treeCanvas{display:block;background:transparent;margin:0 auto}
        .tree-empty{color:var(--muted);text-align:center;padding:24px;font-size:.98rem}
        .tree-legend{position:absolute;left:12px;top:12px;background:rgba(2,6,23,0.85);border-radius:8px;padding:8px 10px;color:var(--muted);font-size:.9rem;border:1px solid rgba(255,255,255,0.02);z-index:10}
        .tree-legend .item{display:flex;gap:8px;align-items:center;margin-bottom:6px}
        .node-dot{width:12px;height:12px;border-radius:50%;display:inline-block}

        .api-status{position:fixed;right:20px;bottom:20px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:10px 14px;border-radius:10px;border-left:4px solid var(--pink);font-size:.92rem;color:var(--muted);box-shadow:0 8px 30px rgba(2,6,23,0.6)}
        .api-status.connected{border-left-color:var(--blue);color:#cfe9ff}
        .api-status.error{border-left-color:var(--yellow);color:#ffe9c2}

        .loading-overlay{position:fixed;left:0;top:0;width:100%;height:100%;background:linear-gradient(180deg, rgba(2,6,23,0.7), rgba(2,6,23,0.85));display:none;align-items:center;justify-content:center;z-index:1000}
        .loading-overlay.active{display:flex}
        .loading-content{text-align:center;color:var(--muted)}
        .spinner{width:50px;height:50px;border-radius:50%;border:4px solid rgba(255,255,255,0.04);border-top-color:var(--pink);animation:spin 1s linear infinite;margin:0 auto 12px}
        @keyframes spin{to{transform:rotate(360deg)}}

        .final-overlay{
            position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:var(--overlay-bg);z-index:2000;
        }
        .final-panel{
            width:min(720px,94%);background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 20px 80px rgba(0,0,0,0.6);color:var(--white);
        }
        .final-header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
        .final-title{font-size:1.4rem;font-weight:900;background:linear-gradient(90deg,var(--pink),var(--yellow));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
        .final-close{background:transparent;border:none;color:var(--muted);cursor:pointer;font-weight:700;font-size:1.4rem}
        .final-body{display:flex;gap:18px;flex-wrap:wrap;align-items:center;justify-content:center;padding:6px 0}
        .final-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));padding:12px;border-radius:10px;min-width:180px;text-align:center;border:1px solid rgba(255,255,255,0.03)}
        .final-winner{font-size:1.6rem;font-weight:900;margin-bottom:6px}
        .final-score{font-size:1.2rem;font-weight:800;color:var(--muted)}
        .final-actions{display:flex;gap:12px;justify-content:center;margin-top:14px}
        .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--white);padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:800}
        .btn-primary{background:linear-gradient(90deg,var(--yellow),var(--pink));padding:10px 12px;border-radius:10px;border:none;color:#071028;cursor:pointer;font-weight:900}

        @media (max-width:980px){
            .main-grid{grid-template-columns:1fr;grid-template-rows:auto auto}
            .cell{width:52px;height:52px}
            .final-body{flex-direction:column}
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ CONNECT 4 AI</h1>
            <p>Score = Number of 4-in-a-rows</p>
        </div>

        <div class="main-grid">
            <div class="card" id="settingsCard">
                <div class="card-header">‚öôÔ∏è Controls</div>
                <div class="controls">
                    <div>
                        <label class="settings-label">Algorithm</label>
                        <div class="radio-group" id="algorithmGroup">
                            <label class="radio-option selected"><input type="radio" name="algorithm" value="minimax" checked> Minimax</label>
                            <label class="radio-option"><input type="radio" name="algorithm" value="alphabeta"> Minimax (Alpha-Beta)</label>
                            <label class="radio-option"><input type="radio" name="algorithm" value="expected"> Expected Minimax</label>
                            <label class="radio-option"><input type="radio" name="algorithm" value="expected_prune"> Expected Minimax (Pruned)</label>
                        </div>
                    </div>

                    <div>
                        <label class="settings-label">Depth (K)</label>
                        <div class="slider-container">
                            <div class="depth-value">K = <span id="depthValue">4</span></div>
                            <input type="range" id="depthSlider" min="1" max="8" value="4" style="width:100%">
                        </div>
                    </div>

                    <div class="controls-actions">
                        <button class="btn btn-start" id="startBtn">‚ñ∂ START</button>
                        <button class="btn btn-reset" id="resetBtn" disabled>‚Üª RESET</button>
                    </div>

                    <div style="height:8px"></div>

                    <div class="status-card" id="summaryCard">
                        <div style="display:flex;flex-direction:column;gap:10px">
                            <div>
                                <div class="status-label">Current Turn</div>
                                <div class="status-value" id="turnStatus">Not Started</div>
                            </div>

                            <div>
                                <div class="status-label">Board Heuristic</div>
                                <div class="status-value" id="heuristicValue" style="color:var(--yellow)">0.0</div>
                            </div>

                            <div style="display:flex;gap:12px">
                                <div style="flex:1">
                                    <div class="status-label">4-in-rows ‚Äî YOU (O)</div>
                                    <div class="status-value" id="scoreHuman">0</div>
                                </div>
                                <div style="flex:1">
                                    <div class="status-label">4-in-rows ‚Äî AI (X)</div>
                                    <div class="status-value" id="scoreAI">0</div>
                                </div>
                            </div>

                            <div>
                                <div class="status-label">Winner</div>
                                <div class="status-value" id="winnerDisplay">‚Äî</div>
                            </div>

                            <div>
                                <div class="status-label">AI Stats</div>
                                <div id="aiStats" style="font-size:.88rem;color:var(--muted)">Waiting...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card board-card" id="boardCard">
                <div class="card-header">üéØ Game Board</div>
                <div class="board-container">
                    <div class="column-indicators" id="columnIndicators"></div>
                    <div class="board-grid" id="boardGrid"></div>

                    <div class="legend">
                        <div class="legend-item"><div class="legend-disc human"></div><span>YOU (O)</span></div>
                        <div class="legend-item"><div class="legend-disc ai"></div><span>AI (X)</span></div>
                    </div>
                </div>
            </div>

            <div class="card tree-area" id="treeCard">
                <div class="card-header">üå≥ Decision Tree</div>
                <div class="tree-canvas-container" id="treeContainer">
                    <div class="tree-legend" id="treeLegend">
                        <div class="item"><span class="node-dot" style="background: linear-gradient(90deg,var(--blue),#8fd1ff)"></span> MAX</div>
                        <div class="item"><span class="node-dot" style="background: linear-gradient(90deg,var(--pink),#ff92d6)"></span> MIN</div>
                        <div class="item"><span class="node-dot" style="background: linear-gradient(90deg,var(--yellow),#ffe7a8)"></span> CHANCE</div>
                        <div class="item"><span class="node-dot" style="background: linear-gradient(90deg,var(--green),#7ae7c7)"></span> OUTCOME</div>
                        <div class="item"><span class="node-dot" style="background: rgba(150,150,150,0.85)"></span> PRUNED</div>
                        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
                            <label style="font-size:.85rem;color:var(--muted);font-weight:700">Zoom</label>
                            <input id="treeZoom" type="range" min="0.5" max="4" step="0.1" value="1" style="flex:1">
                            <div id="treeZoomVal" style="min-width:40px;text-align:center;color:var(--muted);font-weight:700">1.0x</div>
                        </div>
                    </div>

                    <canvas id="treeCanvas"></canvas>
                    <div class="tree-empty" id="treeEmpty">Make your first move to see the decision tree!</div>
                </div>
            </div>
        </div>
    </div>

    <div class="api-status" id="apiStatus">Connecting to Python backend...</div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2 style="color:var(--muted)">AI is thinking...</h2>
        </div>
    </div>

    <div class="final-overlay" id="finalOverlay">
        <div class="final-panel">
            <div class="final-header">
                <div class="final-title">üèÜ Game Over!</div>
                <button class="final-close" id="finalCloseBtn">‚úï</button>
            </div>

            <div class="final-body">
                <div class="final-card">
                    <div class="final-winner" id="finalWinnerText">‚Äî</div>
                    <div class="final-score">Winner</div>
                </div>

                <div class="final-card">
                    <div style="font-weight:900;font-size:1.05rem">Final Score (4-in-a-rows)</div>
                    <div style="display:flex;gap:12px;justify-content:center;margin-top:10px">
                        <div style="text-align:center">
                            <div style="font-size:1.1rem;font-weight:900;color:var(--pink)">YOU (O)</div>
                            <div id="finalScoreO" style="font-size:1.6rem;font-weight:900">0</div>
                        </div>
                        <div style="text-align:center">
                            <div style="font-size:1.1rem;font-weight:900;color:var(--blue)">AI (X)</div>
                            <div id="finalScoreX" style="font-size:1.6rem;font-weight:900">0</div>
                        </div>
                    </div>
                </div>

                <div class="final-card">
                    <div style="font-weight:900;font-size:1.05rem">How the game ended</div>
                    <div id="finalReason" style="color:var(--muted);margin-top:8px;font-size:.95rem">‚Äî</div>
                </div>
            </div>

            <div class="final-actions">
                <button class="btn-ghost" id="finalCloseKeepBtn">Close (keep board)</button>
                <button class="btn-primary" id="finalResetBtn">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:5000';
        let board, gameStarted, currentPlayer, algorithm, depth, lastMove, finalScores, finalWinner, finalReason;
        let NODE_RADIUS = 60, LEVEL_HEIGHT = 220, MIN_NODE_SPACING = 220, PADDING = 80;
        let lastTreeData = null, userZoom = 1.0, initialSummaryHTML = null;

        async function init(){
            await checkAPIConnection();
            createBoard();
            setupEventListeners();
            renderBoard();
            initialSummaryHTML = document.getElementById('summaryCard').innerHTML;
            await updateScores();
        }

        async function checkAPIConnection(){
            try {
                const r = await fetch(`${API_URL}/health`);
                if (r.ok) {
                    document.getElementById('apiStatus').textContent = '‚úì Connected';
                    document.getElementById('apiStatus').className = 'api-status connected';
                } else throw new Error('not ok');
            } catch (err) {
                document.getElementById('apiStatus').textContent = '‚úó Backend not running!';
                document.getElementById('apiStatus').className = 'api-status error';
            }
        }

        function createBoard(){
            board = Array(6).fill(null).map(()=> Array(7).fill('.'));
            gameStarted = false; currentPlayer = 'O'; algorithm = 'minimax'; depth = 4;
            lastMove = null; finalScores = null; finalWinner = null; finalReason = '';
        }

        function setupEventListeners(){
            document.querySelectorAll('input[name="algorithm"]').forEach(radio=>{
                radio.addEventListener('change', e=>{
                    algorithm = e.target.value;
                    document.querySelectorAll('.radio-option').forEach(opt=>opt.classList.remove('selected'));
                    e.target.closest('.radio-option').classList.add('selected');
                });
            });
            document.getElementById('depthSlider').addEventListener('input', e=>{
                depth = parseInt(e.target.value,10);
                document.getElementById('depthValue').textContent = depth;
            });
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('resetBtn').addEventListener('click', resetGame);
            document.getElementById('finalCloseBtn').addEventListener('click', ()=> document.getElementById('finalOverlay').style.display = 'none');
            document.getElementById('finalCloseKeepBtn').addEventListener('click', ()=> document.getElementById('finalOverlay').style.display = 'none');
            document.getElementById('finalResetBtn').addEventListener('click', ()=> { document.getElementById('finalOverlay').style.display = 'none'; resetGame(); });
            
            document.getElementById('treeZoom')?.addEventListener('input', (e)=>{
                userZoom = parseFloat(e.target.value) || 1.0;
                document.getElementById('treeZoomVal').textContent = userZoom.toFixed(1) + 'x';
                if (lastTreeData) drawTree(lastTreeData);
            });
        }

        function renderBoard(){
            const indicatorsDiv = document.getElementById('columnIndicators');
            const boardDiv = document.getElementById('boardGrid');
            indicatorsDiv.innerHTML = '';
            for (let col=0; col<7; col++){
                const ind = document.createElement('div');
                ind.className = 'column-indicator';
                ind.id = `indicator-${col}`;
                ind.textContent = '‚ñº';
                indicatorsDiv.appendChild(ind);
            }
            boardDiv.innerHTML = '';
            for (let row=0; row<6; row++){
                for (let col=0; col<7; col++){
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (gameStarted && currentPlayer === 'O' && !isGameOverFromBackend()){
                        cell.addEventListener('click', ()=> handleCellClick(col));
                        cell.addEventListener('mouseenter', ()=> { if (isValidMove(col)) document.getElementById(`indicator-${col}`).classList.add('active'); });
                        cell.addEventListener('mouseleave', ()=> { document.getElementById(`indicator-${col}`).classList.remove('active'); });
                    }
                    const piece = board[row][col];
                    if (piece === 'O') cell.classList.add('filled','human');
                    else if (piece === 'X') cell.classList.add('filled','ai');
                    if (lastMove && lastMove.col === col){
                        for (let r=5; r>=0; r--){
                            if (board[r][col] !== '.'){
                                if (r === row) cell.classList.add('last-move');
                                break;
                            }
                        }
                    }
                    boardDiv.appendChild(cell);
                }
            }
            updateStatus();
            updateScores();
        }

        function isValidMove(col){ return board[0][col] === '.'; }
        function makeMove(col, player){
            for (let row=5; row>=0; row--){
                if (board[row][col] === '.'){
                    board[row][col] = player;
                    return row;
                }
            }
            return -1;
        }
        function isGameOverFromBackend(){ return finalScores !== null || finalWinner !== null || finalReason !== ''; }

        async function handleCellClick(col){
            if (!gameStarted || currentPlayer !== 'O' || !isValidMove(col) || isGameOverFromBackend()) return;
            makeMove(col,'O');
            lastMove = { col, player: 'O' };
            currentPlayer = 'X';
            renderBoard();
            await updateScores();
            setTimeout(()=> aiMove(), 200);
        }

        async function aiMove(){
            document.getElementById('loadingOverlay').classList.add('active');
            try {
                const res = await fetch(`${API_URL}/ai_move`, {
                    method: 'POST',
                    headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ board, algorithm, depth })
                });
                const result = await res.json();
                document.getElementById('loadingOverlay').classList.remove('active');

                if (!result) {
                    document.getElementById('aiStats').textContent = 'Invalid response';
                    return;
                }

                if (result.current_scores) {
                    document.getElementById('scoreHuman').textContent = result.current_scores.O || 0;
                    document.getElementById('scoreAI').textContent = result.current_scores.X || 0;
                }
                if (typeof result.current_heuristic === 'number') {
                    document.getElementById('heuristicValue').textContent = result.current_heuristic.toFixed(2);
                }

                document.getElementById('aiStats').innerHTML = `<strong>Col:</strong> ${result.move !== null ? (result.move + 1) : '‚Äî'}<br><strong>Score:</strong> ${typeof result.score === 'number' ? result.score.toFixed(2) : '‚Äî'}<br><strong>Time:</strong> ${result.time ?? 'N/A'}ms<br><strong>Nodes:</strong> ${result.nodes ?? 'N/A'}`;

                if (result.tree) {
                    lastTreeData = result.tree;
                    drawTree(result.tree);
                }

                if (result.move !== null && result.move !== undefined){
                    makeMove(result.move, 'X');
                    lastMove = { col: result.move, player: 'X' };
                }

                if (result.game_over) {
                    applyBackendFinalState(result);
                } else {
                    currentPlayer = 'O';
                }

                renderBoard();
                await updateScores();
            } catch (err) {
                document.getElementById('loadingOverlay').classList.remove('active');
                alert('Backend error: ' + err.message);
            }
        }

        function applyBackendFinalState(result){
            finalScores = result.final_scores;
            finalWinner = result.winner;
            finalReason = result.reason || '';
            gameStarted = false;

            document.getElementById('finalScoreO').textContent = finalScores.O ?? 0;
            document.getElementById('finalScoreX').textContent = finalScores.X ?? 0;
            
            const winText = document.getElementById('finalWinnerText');
            if (finalWinner === 'O') {
                winText.textContent = 'YOU WIN! üéâ';
                winText.style.background = 'linear-gradient(90deg,var(--pink),#ff92d6)';
            } else if (finalWinner === 'X') {
                winText.textContent = 'AI WINS ü§ñ';
                winText.style.background = 'linear-gradient(90deg,var(--blue),#82c7ff)';
            } else {
                winText.textContent = 'TIE GAME ü§ù';
                winText.style.background = 'linear-gradient(90deg,var(--yellow),#ffe7a8)';
            }
            winText.style.webkitBackgroundClip = 'text';
            winText.style.webkitTextFillColor = 'transparent';
            
            document.getElementById('finalReason').textContent = finalReason;

            const summaryCard = document.getElementById('summaryCard');
            const winnerLabel = finalWinner === 'O' ? 'YOU (O) WIN' : finalWinner === 'X' ? 'AI (X) WINS' : 'TIE GAME';
            summaryCard.innerHTML = `<div style="display:flex;flex-direction:column;gap:8px"><div style="font-weight:900;font-size:1.05rem;color:var(--muted)">${winnerLabel}</div><div style="display:flex;gap:12px"><div style="flex:1"><div class="status-label">YOU (O)</div><div class="status-value">${finalScores.O ?? 0}</div></div><div style="flex:1"><div class="status-label">AI (X)</div><div class="status-value">${finalScores.X ?? 0}</div></div></div><div style="color:var(--muted);font-size:.9rem">${finalReason}</div></div>`;

            document.getElementById('finalOverlay').style.display = 'flex';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('resetBtn').disabled = false;
            document.querySelectorAll('input[name="algorithm"]').forEach(r=> r.disabled = false);
            document.getElementById('depthSlider').disabled = false;
        }

        async function updateScores(){
            try {
                const res = await fetch(`${API_URL}/heuristic`, {
                    method: 'POST',
                    headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ board })
                });
                const data = await res.json();
                if (data.scores) {
                    document.getElementById('scoreHuman').textContent = data.scores.O || 0;
                    document.getElementById('scoreAI').textContent = data.scores.X || 0;
                }
                if (typeof data.heuristic === 'number') {
                    document.getElementById('heuristicValue').textContent = data.heuristic.toFixed(2);
                }
            } catch (err) {
                console.error('Error updating scores:', err);
            }

            if (finalWinner){
                if (finalWinner === 'O') document.getElementById('winnerDisplay').textContent = 'YOU (O)';
                else if (finalWinner === 'X') document.getElementById('winnerDisplay').textContent = 'AI (X)';
                else document.getElementById('winnerDisplay').textContent = 'TIE';
            } else {
                document.getElementById('winnerDisplay').textContent = '‚Äî';
            }
        }

        function updateStatus(){
            const turnEl = document.getElementById('turnStatus');
            if (!gameStarted) turnEl.textContent = 'Not Started';
            else if (isGameOverFromBackend()) turnEl.textContent = 'Game Over';
            else turnEl.textContent = currentPlayer === 'O' ? 'YOUR TURN (O)' : 'AI THINKING (X)';
        }

        function startGame(){
            gameStarted = true;
            currentPlayer = 'O';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('resetBtn').disabled = false;
            document.querySelectorAll('input[name="algorithm"]').forEach(r=> r.disabled = true);
            document.getElementById('depthSlider').disabled = true;
            renderBoard();
        }

        function resetGame(){
            createBoard();
            lastMove = null; lastTreeData = null;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('resetBtn').disabled = true;
            document.querySelectorAll('input[name="algorithm"]').forEach(r=> r.disabled = false);
            document.getElementById('depthSlider').disabled = false;
            document.getElementById('aiStats').textContent = 'Waiting...';

            const canvas = document.getElementById('treeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('treeEmpty').style.display = 'block';
            canvas.style.display = 'none';

            if (initialSummaryHTML) document.getElementById('summaryCard').innerHTML = initialSummaryHTML;
            renderBoard();
        }

        function drawTree(treeData){
            if (!treeData) return;
            const canvas = document.getElementById('treeCanvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('treeContainer');
            
            document.getElementById('treeEmpty').style.display = 'none';
            canvas.style.display = 'block';

            try {
                const origRadius = NODE_RADIUS, origLevel = LEVEL_HEIGHT, origSpacing = MIN_NODE_SPACING, origPadding = PADDING;
                NODE_RADIUS = Math.max(20, Math.round(NODE_RADIUS * 1.0));
                LEVEL_HEIGHT = Math.max(90, Math.round(LEVEL_HEIGHT * 0.6));
                MIN_NODE_SPACING = Math.max(60, Math.round(MIN_NODE_SPACING * 0.35));
                PADDING = Math.max(40, Math.round(PADDING * 0.6));

                const treeMetrics = calculateTreeMetrics(treeData);
                const rawWidth = Math.max(treeMetrics.width + PADDING * 2, 1000);
                const rawHeight = Math.max(treeMetrics.height + PADDING * 2, 500);

                const renderWidth = Math.min(rawWidth, 10000);
                const renderHeight = Math.min(rawHeight, 6000);

                canvas.width = renderWidth;
                canvas.height = renderHeight;
                ctx.clearRect(0, 0, renderWidth, renderHeight);

                const drawScale = renderWidth / rawWidth;
                ctx.save();
                ctx.scale(drawScale, drawScale);
                drawNode(ctx, treeData, rawWidth / 2, PADDING + NODE_RADIUS, 0, rawWidth - PADDING * 2);
                ctx.restore();

                const containerWidth = container.clientWidth - 24;
                const baseFit = containerWidth / renderWidth;
                const fitScale = Math.min(8, Math.max(0.6, baseFit * userZoom));
                canvas.style.transformOrigin = '50% 0';
                canvas.style.transform = `scale(${fitScale})`;
                canvas.style.width = renderWidth + 'px';
                canvas.style.height = renderHeight + 'px';
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';

                container.scrollLeft = Math.max(0, (renderWidth * fitScale - container.clientWidth) / 2);

                lastTreeData = treeData;
                NODE_RADIUS = origRadius; LEVEL_HEIGHT = origLevel; MIN_NODE_SPACING = origSpacing; PADDING = origPadding;
            } catch (err) {
                console.error('Error drawing tree:', err);
                document.getElementById('treeEmpty').textContent = 'Error rendering tree: ' + err.message;
                document.getElementById('treeEmpty').style.display = 'block';
                canvas.style.display = 'none';
            }
        }

        function calculateTreeMetrics(node, level = 0){
            if (!node) return { width: 0, height: 0, leaves: 0 };
            if (!node.children || node.children.length === 0){
                return { width: MIN_NODE_SPACING, height: LEVEL_HEIGHT * (level + 1), leaves: 1 };
            }
            let totalLeaves = 0, maxHeight = 0;
            for (const child of node.children){
                const childMetrics = calculateTreeMetrics(child, level + 1);
                totalLeaves += childMetrics.leaves;
                maxHeight = Math.max(maxHeight, childMetrics.height);
            }
            return {
                width: Math.max(totalLeaves * MIN_NODE_SPACING, MIN_NODE_SPACING * node.children.length),
                height: maxHeight,
                leaves: totalLeaves
            };
        }

        function drawNode(ctx, node, x, y, level, availableWidth){
            if (!node) return;

            const colors = {
                'MAX': { fill: 'rgba(77, 163, 255, 0.9)', stroke: '#4da3ff' },
                'MIN': { fill: 'rgba(255, 107, 203, 0.9)', stroke: '#ff6bcb' },
                'CHANCE': { fill: 'rgba(255, 209, 102, 0.9)', stroke: '#ffd166' },
                'OUTCOME': { fill: 'rgba(6, 214, 160, 0.9)', stroke: '#06d6a0' },
                'LEAF': { fill: 'rgba(6, 214, 160, 0.9)', stroke: '#06d6a0' },
                'PRUNED': { fill: 'rgba(160, 160, 160, 0.95)', stroke: '#8f8f8f' }
            };

            const effectiveType = (node.pruned || node.type === 'PRUNED') ? 'PRUNED' : node.type;
            const color = colors[effectiveType] || { fill: '#666', stroke: '#444' };

            ctx.beginPath();
            ctx.arc(x, y, NODE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = color.fill;
            ctx.fill();
            ctx.strokeStyle = color.stroke;
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${Math.max(11, Math.round(NODE_RADIUS * 0.5))}px system-ui`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(node.label || node.type, x, y - NODE_RADIUS - 5);

            const scoreText = typeof node.score === 'number' ? node.score.toFixed(1) : (node.score || '');
            ctx.font = `bold ${Math.max(12, Math.round(NODE_RADIUS * 0.45))}px system-ui`;
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#071028';
            ctx.fillText(scoreText, x, y);

            if ((node.alpha !== undefined && node.alpha !== null) || (node.beta !== undefined && node.beta !== null)) {
                const alphaVal = (node.alpha !== null && node.alpha !== undefined && isFinite(node.alpha)) ? Number(node.alpha).toFixed(1) : 'N/A';
                const betaVal = (node.beta !== null && node.beta !== undefined && isFinite(node.beta)) ? Number(node.beta).toFixed(1) : 'N/A';
                ctx.font = `${Math.max(10, Math.round(NODE_RADIUS * 0.18))}px system-ui`;
                ctx.textBaseline = 'top';
                ctx.fillStyle = '#cfe9ff';
                ctx.fillText(`Œ±:${alphaVal} Œ≤:${betaVal}`, x, y + NODE_RADIUS + 6);
            }

            if (node.pruned || node.type === 'PRUNED') {
                ctx.font = `bold ${Math.max(12, Math.round(NODE_RADIUS * 0.45))}px system-ui`;
                ctx.fillStyle = '#ffdd99';
                ctx.fillText('‚úÇ', x + NODE_RADIUS - 18, y - NODE_RADIUS + 6);
            }

            if (node.children && node.children.length > 0){
                const childY = y + LEVEL_HEIGHT;
                const childCount = node.children.length;
                let positions = [];
                if (childCount === 1) {
                    positions = [x];
                } else {
                    const spacing = Math.max(MIN_NODE_SPACING, availableWidth / (childCount + 1));
                    const totalWidth = spacing * (childCount - 1);
                    const startX = x - totalWidth / 2;
                    for (let i = 0; i < childCount; i++) positions.push(startX + (i * spacing));
                }

                for (let i = 0; i < childCount; i++){
                    const childX = positions[i];
                    const child = node.children[i];

                    ctx.beginPath();
                    ctx.moveTo(x, y + NODE_RADIUS);
                    ctx.lineTo(childX, childY - NODE_RADIUS);
                    const childIsPruned = (child && (child.type === 'PRUNED' || child.pruned));
                    ctx.strokeStyle = childIsPruned ? 'rgba(120,120,120,0.45)' : 'rgba(255, 255, 255, 0.15)';
                    ctx.lineWidth = childIsPruned ? 1.5 : 2;
                    ctx.stroke();

                    const childWidth = childCount === 1 ? availableWidth : availableWidth / childCount;
                    drawNode(ctx, child, childX, childY, level + 1, childWidth);
                }
            }
        }

        init();
    </script>
</body>
</html>